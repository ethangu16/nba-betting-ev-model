import pandas as pd
import xgboost as xgb
import numpy as np
import matplotlib.pyplot as plt
import joblib
import os
import sys

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
from src.utils.betting_advanced import calculate_expected_value

# --- CONFIGURATION ---
DATA_PATH = 'data/processed/nba_model_with_odds.csv'
MODEL_PATH_JSON = 'models/nba_xgb_model.json'
MODEL_PATH_JOBLIB = 'models/nba_xgb_model.joblib'

# BANKROLL SETTINGS (Match predict_today.py exactly)
INITIAL_BANKROLL = 10000
KELLY_FRACTION = 0.35  # Match predict_today.py (35% of optimal)
MAX_BET_PCT = 0.05     # Cap: Never bet more than 5% of bankroll on one game
MIN_EDGE_THRESHOLD = 0.02  # Match predict_today.py (minimum 2% edge)
MAX_EDGE_THRESHOLD = 0.15  # Match predict_today.py (maximum 15% edge)
MIN_WIN_PROB = 0.30    # Match predict_today.py
MAX_WIN_PROB = 0.90    # Match predict_today.py
PROB_CALIBRATION_FACTOR = 1.0  # Match predict_today.py
USE_SIGMOID_CALIBRATION = False  # Match predict_today.py

def get_implied_prob(moneyline):
    """Converts American Odds (-150, +130) to Implied Probability (0-1)."""
    if pd.isna(moneyline) or moneyline == 0: return None
    if moneyline < 0:
        return (-moneyline) / (-moneyline + 100)
    else:
        return 100 / (moneyline + 100)

def get_decimal_odds(moneyline):
    """Converts American Odds to Decimal Odds (e.g. -110 -> 1.91)"""
    if pd.isna(moneyline) or moneyline == 0: return None
    if moneyline < 0:
        return 1 + (100 / -moneyline)
    else:
        return 1 + (moneyline / 100)

def load_model():
    """Smart loader that checks for json or joblib"""
    if os.path.exists(MODEL_PATH_JSON):
        print(f"Loading XGBoost from {MODEL_PATH_JSON}...")
        model = xgb.XGBClassifier()
        model.load_model(MODEL_PATH_JSON)
        return model
    elif os.path.exists(MODEL_PATH_JOBLIB):
        print(f"Loading XGBoost from {MODEL_PATH_JOBLIB}...")
        return joblib.load(MODEL_PATH_JOBLIB)
    else:
        raise FileNotFoundError("âŒ Could not find trained model.")
def backtest():
    print("--- STARTING BACKTEST ---")
    
    # 1. Load Data
    if not os.path.exists(DATA_PATH):
        print(f"âŒ Error: Data file not found at {DATA_PATH}")
        return

    df = pd.read_csv(DATA_PATH, low_memory=False)
    print(f"ðŸ“„ Loaded {len(df)} rows from dataset.")

    # --- ðŸ› ï¸ FEATURE VALIDATION BLOCK ---
    # The model uses ROLL_OFF_RTG, not ROLL_PTS. Check for required features.
    required_features = [
        'ROLL_OFF_RTG', 'ROLL_DEF_RTG', 'ROLL_PACE',
        'ROLL_EFG_PCT', 'ROLL_TOV_PCT', 'ROLL_ORB_PCT', 'ROLL_FTR',
        'ROLL_ROSTER_TALENT_SCORE'
    ]
    missing_features = [f for f in required_features if f not in df.columns]
    if missing_features:
        print(f"âš ï¸ Missing required features: {missing_features}")
        print("   These features should be generated by engineer.py")
        print("   Backtest may not work correctly without them.")

    # --- ðŸ› ï¸ DATA PATCHING BLOCK (Odds) ---
    if 'MONEYLINE' not in df.columns:
        print("ðŸ” Mapping 'HOME_ML' / 'AWAY_ML' to 'MONEYLINE' column...")
        required_cols = {'HOME_ML', 'AWAY_ML', 'IS_HOME'}
        if required_cols.issubset(df.columns):
            df['MONEYLINE'] = np.where(df['IS_HOME'] == 1, df['HOME_ML'], df['AWAY_ML'])
            print(f"âœ… Successfully mapped odds to 'MONEYLINE'.")
        else:
            print(f"âŒ Critical: Missing columns in CSV: {required_cols - set(df.columns)}")
            return

    # --- ðŸ§¹ FILTERING BLOCK ---
    # Drop rows where MONEYLINE is NaN or 0, AND where required features are NaN
    filter_cols = ['MONEYLINE', 'ROLL_OFF_RTG', 'ELO_TEAM']
    df_clean = df.dropna(subset=filter_cols).copy()
    df_clean = df_clean[df_clean['MONEYLINE'] != 0]

    dropped_count = len(df) - len(df_clean)
    print(f"ðŸ“‰ Filtered Data: {len(df_clean)} valid betting opportunities.")
    print(f"   (Skipped {dropped_count} rows due to missing odds or rolling stats)")

    if len(df_clean) == 0:
        print("âŒ No valid games left. Check your data source.")
        return

    df_clean = df_clean.sort_values('GAME_DATE')
    
    # 2. Split Test Set (Last 20% of VALID games)
    split_index = int(len(df_clean) * 0.80)
    test_df = df_clean.iloc[split_index:].copy()
    print(f"ðŸš€ Backtesting on {len(test_df)} games...")
    
    # 3. Load Model
    try:
        model = load_model()
    except Exception as e:
        print(e)
        return

    # Define Features
    features = [
        'ELO_TEAM', 'ELO_OPP', 
        'IS_HOME', 'IS_B2B', 'IS_3IN4',
        'ROLL_OFF_RTG', 'ROLL_DEF_RTG', 'ROLL_PACE',
        'ROLL_EFG_PCT', 'ROLL_TOV_PCT', 'ROLL_ORB_PCT',
        'ROLL_FTR', 'ROLL_ROSTER_TALENT_SCORE'
    ]
    
    # Verify features exist
    missing_feats = [f for f in features if f not in test_df.columns]
    if missing_feats:
        print(f"âŒ Still missing columns: {missing_feats}")
        return

    print("ðŸ§  Generating AI predictions...")
    # Use same approach as predict_today: XGBoost only (no Monte Carlo in backtest)
    # In production, we use 70% XGBoost + 30% Monte Carlo, but for backtest
    # we only have XGBoost predictions, so we use those directly
    probs = model.predict_proba(test_df[features])[:, 1]
    test_df['MODEL_PROB'] = probs
    
    # 4. Run Simulation
    bankroll = INITIAL_BANKROLL
    history = [INITIAL_BANKROLL]
    
    stats = {'bets_placed': 0, 'wins': 0, 'losses': 0, 'skipped_low_edge': 0}
    
    print("\n--- SIMULATING WAGERS ---")
    
    def calibrate_probability(prob):
        """Match predict_today.py calibration"""
        if not USE_SIGMOID_CALIBRATION:
            return prob
        CALIBRATION_STRENGTH = 0.3
        calibrated = 0.5 + (prob - 0.5) * (1 - CALIBRATION_STRENGTH)
        return calibrated
    
    def get_kelly_bet(prob_win, decimal_odds, implied_prob, bankroll):
        """Match predict_today.py Kelly calculation exactly"""
        # Calibrate probability
        calibrated_prob = calibrate_probability(prob_win)
        
        # Calculate edge
        edge = calibrated_prob - implied_prob
        
        # Cap maximum edge
        if edge > MAX_EDGE_THRESHOLD:
            edge = MAX_EDGE_THRESHOLD
            calibrated_prob = implied_prob + edge
        
        # Check minimum edge threshold
        if edge < MIN_EDGE_THRESHOLD:
            return (0.0, 0.0, edge, calibrated_prob)
        
        # Check win probability bounds
        if calibrated_prob < MIN_WIN_PROB or calibrated_prob > MAX_WIN_PROB:
            return (0.0, 0.0, edge, calibrated_prob)
        
        # Apply edge dampening
        edge = edge * PROB_CALIBRATION_FACTOR
        calibrated_prob = implied_prob + edge
        
        # Kelly formula
        b = decimal_odds - 1
        p = calibrated_prob
        q = 1.0 - p
        
        if b <= 0:
            return (0.0, 0.0, edge, calibrated_prob)
        
        kelly_pct = (b * p - q) / b
        
        # Only bet if positive Kelly
        if kelly_pct <= 0:
            return (0.0, 0.0, edge, calibrated_prob)
        
        # Calculate raw bet (before cap)
        raw_bet_pct = kelly_pct * KELLY_FRACTION
        raw_bet_amount = bankroll * raw_bet_pct
        
        # Apply max bet cap
        bet_pct = min(raw_bet_pct, MAX_BET_PCT)
        bet_amount = bankroll * bet_pct
        
        return (bet_amount, raw_bet_amount, edge, calibrated_prob)
    
    for index, row in test_df.iterrows():
        odds = row['MONEYLINE']
        implied_prob = get_implied_prob(odds)
        decimal_odds = get_decimal_odds(odds)
        model_prob = row['MODEL_PROB']
        
        if implied_prob is None: continue
        
        # Use same Kelly calculation as predict_today.py
        bet_amount, raw_bet, edge, calib_prob = get_kelly_bet(
            model_prob, decimal_odds, implied_prob, bankroll
        )
        
        if bet_amount > 0:
            stats['bets_placed'] += 1
            b = decimal_odds - 1
            
            if row['TARGET_WIN'] == 1:
                bankroll += bet_amount * b
                stats['wins'] += 1
            else:
                bankroll -= bet_amount
                stats['losses'] += 1
        else:
            if edge < MIN_EDGE_THRESHOLD:
                stats['skipped_low_edge'] += 1
            elif calib_prob < MIN_WIN_PROB or calib_prob > MAX_WIN_PROB:
                stats['skipped_low_edge'] += 1  # Count as skipped
            else:
                stats['skipped_low_edge'] += 1
            
        history.append(bankroll)

    # 5. Report & Plot
    total_return = ((bankroll - INITIAL_BANKROLL) / INITIAL_BANKROLL) * 100
    win_rate = (stats['wins'] / stats['bets_placed'] * 100) if stats['bets_placed'] > 0 else 0
    
    print("\n" + "="*40)
    print(f"ðŸ’° FINAL BANKROLL: ${bankroll:,.2f}")
    print(f"ðŸ“ˆ Total ROI:      {total_return:+.2f}%")
    print("="*40)
    print(f"Bets Placed:       {stats['bets_placed']}")
    print(f"Win Rate:          {win_rate:.2f}%")
    
    if len(history) > 1:
        plt.figure(figsize=(10, 6))
        plt.plot(history, label='AI Strategy', color='green')
        plt.axhline(y=INITIAL_BANKROLL, color='r', linestyle='--')
        plt.title(f"Backtest ROI: {total_return:.2f}%")
        plt.grid(True, alpha=0.3)
        plt.savefig("results/backtest_chart.png")
        print("âœ… Chart saved to results/backtest_chart.png")

if __name__ == "__main__":
    backtest()